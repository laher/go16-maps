Go 1.6 - Concurrent Map Access
Golang Auckland Meetup Group
17 Feb 2015
Tags: GoAKL, Go, Go1.6, Auckland, Hapara

Am Laher
Gopher, Hapara Inc.
am.laher@hapara.com
https://github.com/laher/maps

* Go 1.6 announcement.

.image party-gopher.png

Announcement:

.link https://tip.golang.org/doc/go1.6

Slides:

.link https://talks.golang.org/2016/state-of-go.slide#1 

* Concurrent Map Access

- Go now crashes when you trigger a data race in maps.
- Uergh.

* Topics Introduced

- Concurrency
- Race conditions
- Race detector
- Maps (dictionaries / hashtables)
- Goroutines; Mutexes vs Channels

* Introduction

Go maps have always been sensitive to data races.

.link http://dave.cheney.net/2015/12/07/are-go-maps-sensitive-to-data-races

This article gives some more details about the perils of data races.

.link https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong

But now, Go will crash _with more certainty_ when you trigger one.

* Example

_Run these examples with & without the race detector. Also, with go1.5 vs go1.6_

.play map_unsafe.go

* Force the race condition

Speed up the program to force the data race.

.play map_unsafe_faster.go

* Protect yourself with panic/recover?

No recovery!

.play map_unsafe_norecovery.go

* What to do?

Use the race detector. Keep using it.
Use a 'memory barrier primitive', e.g.
- sync.Mutex or sync.RWMutex
- Wut, locks? But, but, but ... Hoare's CSP?!

* Solution 1

.play map_safe_mutex.go

* Solution 2

A silly but more CSP-ish option.

.play map_safe_select.go

* Solution 3

Still silly, but more useful. 
 
- Note that it doesn't support concurrent reads.

.play map_safe_select_refactor.go

* Other design considerations

- Populate your map up-front in a single goroutine.
- Be judicious with use of maps.
- Share the value, not the whole map?
- Use a struct / slice where possible?
- Get the race detector into your build process
